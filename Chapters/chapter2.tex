\addcontentsline{toc}{chapter}{Client C$\#$}

\chapter{Client C$\#$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Struttura Generale}

Per l'implementazione si è cercato di seguire le best practices, dettate dalle linee guida Microsoft, per la stesura del codice.
Sono stati adottati, come pattern di programmazione, dependency injection, MVC (per quanto possibile) e TDD, appoggiandosi a librerie esterne Nuget\footnote{
    \textbf{Nuget} è un package manager per .NET. \href{https://www.nuget.org/}{Sito ufficiale}
} quali 
\href{https://www.nuget.org/packages/newtonsoft.json/}{Newtonsoft.Json} e \href{https://www.nuget.org/packages/SimpleInjector/}{SimpleInjector}. I metodi sono asincroni e le property thread-safe.

La solution è stata partizionata in vari progetti; il progetto Business contiene la business-logic 
(comprendente servizi, metodi estensione, l'implementazione del client e un wrapper del Container di SimpleInjector) e utilizza i modelli di Domain.

In Test sono contenute le classi di testing e le fixture XUnit\footnote{
    \textbf{XUnit} è una libreria \href{https://www.nuget.org/packages/xunit/}{Nuget} che mette a disposizione un tool per eseguire unit test. \href{https://github.com/xunit/xunit}{Repository GitHub}    
}, mentre in Documentation sono presenti i file generati dal tool Wyam\footnote{
    \textbf{Wyam} è un tool che permette l'esportazione della documentazione del codice C$\#$ 
    (sottoforma di \href{https://docs.microsoft.com/en-us/dotnet/csharp/codedoc}{tag xml}) in pagine html. \href{https://wyam.io/}{Sito ufficiale}
} per la documentazione.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Il Client}

Dalla documentazione ufficale delle API di Dandelion si evince che ogni end-point richiede uno o più testi da analizzare ed una serie di parametri, alcuni obbligatori ed altri 
opzionali; 
pertanto sono stati creati dei modelli, coerenti con tali definizioni, che, passati in argomento a dei servizi, ritornano i DTO delle risposte degli end-point di Dandelion.

Ogni servizio controlla che i parametri inseriti dall'utente rispettino i constraints definiti nella documentazione e costruisce, tramite i metodi \code{ContentBuilder()} e  
\code{UriBuilder()}, un dizionario di parametri e l'URI che identifica l'end-point. 

Infine il servizio chiama il metodo generico \code{CallApiAsync()}, passandogli il content, la URI ed il metodo HTTP; 
nel metodo di chiamata si è scelto di gestire separatamente i metodi HTTP GET e DELETE dato che essi non permettono il passaggio parametri nel boby 
della chiamata. Pertanto è stato necessario inviare il content come query parameter facendone il percent-encoding.

Dandelion ammette sia chiamate GET che POST ai servizi, tuttavia nel caso del metodo GET non è garantito il corretto 
funzionamento del servizio per testi che superano i 2000 caratteri; pertanto nel caso in cui l'utente non specifichi il metodo HTTP, di default verrà
usato il metodo POST.

Se la chiamata è andata a buon fine il JSON di ritorno viene mappato in un DTO specifico, a seconda del servizio scelto, e restitiuito direttamente all'utente.

\begin{lstlisting}[style=CSharpStyle, caption=Metodo generico del client per le chiamate HTTP]
public Task<T> CallApiAsync<T>(string uri, List<KeyValuePair<string, string>> content, HttpMethod method = null)
{
    var result = new HttpResponseMessage();
    if (method == null)
    {
        method = HttpMethod.Post;
    }

    if (_client.BaseAddress == null)
    {
        _client.BaseAddress = new Uri(Localizations.BaseUrl);
    }

    return Task.Run(async () =>
    {
        if (method == HttpMethod.Get)
        {
            string query;
            using (var encodedContent = new FormUrlEncodedContent(content))
            {
                query = encodedContent.ReadAsStringAsync().Result;
            }
            result = await _client.GetAsync($"{uri}/?{query}");
        }
        else if (method == HttpMethod.Delete)
        {
            string query;
            using (var encodedContent = new FormUrlEncodedContent(content))
            {
                query = encodedContent.ReadAsStringAsync().Result;
            }
            result = await _client.DeleteAsync($"{uri}/?{query}");
        }
        else
        {
            var httpContent = new HttpRequestMessage(method, uri);
            if (content != null)
            {
                httpContent.Content = new FormUrlEncodedContent(content.ToArray());
            }
            result = await _client.SendAsync(httpContent);
        }
        string resultContent = await result.Content.ReadAsStringAsync();
        if (result.StatusCode == System.Net.HttpStatusCode.RequestUriTooLong)
        {
            throw new ArgumentException(ErrorMessages.UriTooLong);
        }
        if (!result.IsSuccessStatusCode)
        {
            throw new Exception(resultContent); 
        }
        return JsonConvert.DeserializeObject<T>(resultContent);
    });
}
\end{lstlisting}

\section{Testing}
La maggiorparte dei servizi è stata testata tramite il tool XUnit; principalmente sono stati eseguiti test di validazione, data la natura della libreria, appoggiandosi 
ad una fixture comune a tutti i test per l'inizializzazione dei servizi.

è stato usato fin da subito il servizio online di testing automatico Travis, tramite il quale è stato possibile validare ogni rilascio facendo 
partire automaticamente i test con l'evento di push di Git. 

\section{Documentazione}
Infine le classi e i metodi più rilevanti sono stati commentati tramite i tag XML specificati nella documentazione Microsoft e la documentazione in formato 
HTML è stata generata automaticamente tramite il tool Wyam.

\section{Nuget}
La dll generata dalla compilazione della libreria è stata infine documentata sotto il profilo delle dipendenze, generando il file .nuspec, ed inclusa nel file .nupkg
tramite l'apposito tool fornito da Nuget. Il tutto è stato caricato sul portale online Nuget ed è ora possibile includerlo in un progetto tramite il comando cli:

\begin{lstlisting}[style=TexStyle]
$ dotnet add package SpazioDati.Dandelion
\end{lstlisting}